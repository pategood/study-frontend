function f1() {
  var n = 999;
  nAdd = function () {
    n += 1
  }

  function f2() {
    alert(n);
  }
  return f2;
}
var result = f1();
result(); // 999 
nAdd();
result(); // 1000



// 解释

var result=f1()：f1函数返回了f2函数
把返回的f2函数赋值给result全局变量，（f2的作用域链保存到result全局变量中）
result()：调用result()，这就形成闭包：有权访问另外一个函数作用域中的变量
因为在f2中的作用域引用了f1中的n这个局部变量，当f1执行完毕后，垃圾回收机制发现n变量还在被result中引用所以垃圾回收机制不会把n回收释放。
以至于n一直保存在result作用域链中。result的作用域链正常能访问f1中的局部变量n，形成闭包。
nAdd()：nAdd没有写var所以nAdd是全局变量，在调用nAdd()和result()是一样的都会形成闭包，匿名函数function(){n+=1}的作用域链中有n这个局部变量，所以当nAdd=funtion(){n+=1}时，这个匿名函数的作用域链保存到了全局变量nAdd形成闭包，调用nAdd()作用域链中找到f1局部变量n=999，n+1=1000。
result()：result()就输出1000
nAdd();重复第三步骤 n+1 = 1001
result();重复第四步骤 输出n
f1();调用f1时并没有形成闭包，n永远都是999,因为每次f1执行结束后n都被垃圾回收机制销毁了，所以这里再次调用 var n=999；后面输出也都是999
为什么 nAdd 的表达式会影响到 f2 的 n？
因为闭包的原因n一直都没被销毁，nAdd()也形成了闭包，并改变了n的值，所以后面再次调用result() n没被销毁回收一直被+1，所以会被影响。
最后在调用f1()时没有闭包，之前n是被销毁了。所以一直输出a=999；