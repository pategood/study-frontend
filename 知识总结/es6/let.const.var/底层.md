一.
  1.for(let i=0;i<5;i++;)  这圆括号内有一个隐藏的作用域
  2.for(let i=0;i<5;i++;){循环体} 在每一次执行循环体之前,js引擎会把i在循环体的上下文重新声明及初始化一次
  也就是说上面的代码段2可以近似近似近似地理解为
  // 代码段3
  var liList = document.querySelectorAll('li') // 共5个li
  for( let i=0; i<liList.length; i++){
    let i = 隐藏作用域中的i // 看这里看这里看这里
    liList[i].onclick = function(){
      console.log(i)
    }
  }

二.
提升的本质，需要理解 JS 变量的「创建create、初始化initialize 和赋值assign」

有的地方把创建说成是声明（declare），为了将这个概念与变量声明区别开，我故意不使用声明这个字眼。

有的地方把初始化叫做绑定（binding），但我感觉这个词不如初始化形象。

看看 var 声明的「创建、初始化和赋值」过程
例如:
function fn(){
  var x = 1
  var y = 2
}
fn()

在执行 fn 时，会有以下过程（不完全）：

进入 fn，为 fn 创建一个环境。
找到 fn 中所有用 var 声明的变量，在这个环境中「创建」这些变量（即 x 和 y）。
将这些变量「初始化」为 undefined。
开始执行代码
x = 1 将 x 变量「赋值」为 1
y = 2 将 y 变量「赋值」为 2
也就是说 var 声明会在代码执行之前就将「创建变量，并将其初始化为 undefined」。

这就解释了为什么在 var x = 1 之前 console.log(x) 会得到 undefined。


看 function 声明的「创建、初始化和赋值」过程
fn2()

function fn2(){
  console.log(2)
}

JS 引擎会有一下过程：

找到所有用 function 声明的变量，在环境中「创建」这些变量。
将这些变量「初始化」并「赋值」为 function(){ console.log(2) }。
开始执行代码 fn2()

function 声明会在代码执行之前就「创建、初始化并赋值」。

接下来:
{
  let x = 1
  x = 2
}

{}里面的let先创建,但不初始化,  
  接着遇到x=1则初始化为1,但这不是赋值
  如果遇到let x,则初始化为undefined

接着又遇到x=2则对x进行赋值

这就解释了为什么在 let x 之前使用 x 会报错：


let x = 'global'
{
  console.log(x) // Uncaught ReferenceError: x is not defined
  let x = 1
}

console.log(x) 中的 x 指的是下面的 x，而不是全局的 x
执行 log 时 x 还没「初始化」，只进行了创建 所以不能使用（也就是所谓的暂时死区）


延申:
代码1:
  var foo
  function foo(){}
  console.log(foo)

代码2:
  function foo(){}
  var foo
  console.log(foo)

请问代码1 和 代码2 的输出分别是什么？
  
答案:
  由于 function 比 var 多一个「赋值」过程，所以两个代码的输出都是函数。
  你也可以记住结论：function 比 var 牛逼。

  那如果 function foo 和 let foo 同时出现呢？不会有这种情况的，
  因为 let 发现重名就会报错，叫你滚去改代码。


三.
const:
  其实 const 和 let 只有一个区别，那就是 const 只有「创建」和「初始化」，没有「赋值」过程。
  https://pic1.zhimg.com/80/v2-9c8c4a0a3ce5402b1a74f488d79c74d0_720w.png



如果 let x 的初始化过程失败了，那么

x 变量就将永远处于 created 状态。
你无法再次对 x 进行初始化（初始化只有一次机会，而那次机会你失败了）。
由于 x 无法被初始化，所以 x 永远处在暂时死区（也就是盗梦空间里的 limbo）！
有人会觉得 JS 坑，怎么能出现这种情况；其实问题不大，因为此时代码已经报错了，后面的代码想执行也没机会。
