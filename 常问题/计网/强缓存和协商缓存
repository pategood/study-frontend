如果你只设置了cahe-control:max-age=31536000,public 这属于强缓存，
每次用户正常打开这个页面，浏览器会判断缓存是否过期，没有过期就从缓存中读取数据；
但是有一些 "聪明" 的用户会点击浏览器左上角的刷新按钮去刷新页面，
这时候就算资源没有过期（1年没这么快过），浏览器也会直接去请求服务器，
这就是额外的请求消耗了，这时候就相当于是走协商缓存的流程了

强缓存: 
  强缓存就是给资源设置个过期时间，客户端每次请求资源时都会看是否过期；
  只有在过期才会去询问服务器

协商缓存 :  协商缓存就是需要客户端和服务器两端进行交互的。
强缓存总结
1.cache-control: max-age=xxxx，public
  客户端和代理服务器都可以缓存该资源；
  客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，如果用户做了刷新操作，就向服务器发起http请求

2.cache-control: max-age=xxxx，private
  只让客户端可以缓存该资源；代理服务器不缓存
  客户端在xxx秒内直接读取缓存,statu code:200

3.cache-control: max-age=xxxx，immutable
  客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，即使用户做了刷新操作，也不向服务器发起http请求

4.cache-control: no-cache
  跳过设置强缓存，但是不妨碍设置协商缓存；一般如果你做了强缓存，只有在强缓存失效了才走协商缓存的，设置了no-cache就不会走强缓存了，每次请求都回询问服务端。

5.cache-control: no-store
  不缓存，这个会让客户端、服务器都不缓存，也就没有所谓的强缓存、协商缓存了。


  协商缓存设置:
    怎么设置协商缓存？

  response header里面的设置
      etag: '5c20abbd-e2e8'
      last-modified: Mon, 24 Dec 2018 09:49:49 GMT


  每次请求返回来 response header 中的 etag和 last-modified，
  在下次请求时在 request header 就把这两个带上，服务端把你带过来的标识进行对比，
  然后判断资源是否更改了，
  如果更改就直接返回新的资源，和更新对应的response header的标识etag、last-modified。
  如果资源没有变，那就不变etag、last-modified，这时候对客户端来说，每次请求都是要进行协商缓存

协商缓存过程:
发请求-->看资源是否过期-->过期-->请求服务器-->
  服务器对比资源是否真的过期-->没过期-->返回304状态码-->客户端用缓存的老资源。



请求资源时，把用户本地该资源的 etag、last-modified 同时带到服务端，服务端和最新资源做对比。
如果资源没更改，返回304，浏览器读取本地缓存。
如果资源有更改，返回200，返回最新的资源。