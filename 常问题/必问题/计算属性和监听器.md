一.应用场景:
  computed  是计算的内容需要依赖多个属性的情况
  watch   计算的内容依赖一个属性的情况

二.
计算属性缓存结果时每次都会重新创建变量
侦听器是直接计算，不会创建变量保存结果

也就意味着，数据如果会反复的发生变化，计算很多次的情况下，计算属性的开销将会更大，
也就意味着这种情况不适合使用计算属性，适合使用侦听器
那么，如果一个数据反复会被使用，但是它计算依赖的内容很少发生变化的情况下，
计算属性会缓存结果，就更加适合这种情况

三.computed的结果是通过return返回的，而watch不需要return。

四.
watch的参数可以获取监听的属性改变后最新的值,
一个侦听器对应data中的一个属性，当属性发生变化时触发侦听器的执行。

watch只会监听数据的值是否发生改变，而不会监听地址的变化，如果需要监听引用类型的数据变化，
需要深度监听：
obj:{
    handler(newVal){

    },
    deep:true
  }------用handler+deep的方式进行深度监听。
在特殊的情况下(更改数组中的数据时，数组已经更改，但是视图没有更新)，watch无法监听数组的变化,更改数组必须要用splice()或者$set。

变量不在 data中定义，而是定义在computed中

我们在计算开销比较大(计算次数多或者异步处理)的时候，会使用侦听器watch来得到计算结果。
而其他情况建议使用计算属性computed，因为缓存节省多次计算的性能。